## 思路:  
观察数组寻找一个数是一行的最大值，同时是一列最小值这样判断可以直接一行or一列  
`右上角 or 左下角`

## 题目：
在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。  
请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。  
[1,2,8,9]  
[2,4,9,12]  
[4,7,10,13]  
[6,8,11,15]  
给定 target = 7，返回 true。  
给定 target = 3，返回 false。  

数据范围：矩阵的长宽满足 0 <= n,m≤500 ， 矩阵中的值满足 0 \≤val≤10^9  
进阶：空间复杂度 O(1) ，时间复杂度 O(n+m)  

## 知识点  
### C++输入输出 
  
输入流：遇到回车全部放入缓冲区才开始读  
`cin可以忽略回车，空格;cin.get() 返回的ascii 默认的char型`
>如 while（cin>>num）{cin.get(); cin.get;}  
  输入：1空格2空格3空格空格回车  
  输出：cin读了1 cin.get读了空格  cin.get读了2返回2的ascii码 cin读了3 cin.get 读了俩个空格此时，此时停止读取缓存区还有一个回车。  
  输入：1空格空格空格3回车  
  cin读了1 cin.get读了空格  cin.get读了空格  cin读3 cin.get读了回车，cin前的空格会从缓冲区消失。  
  `如果替换If（cin.get）也使一样的效果`   
  `cin先读因为在while里 然后是cin.get`    

> LineCount=1  
> while (cin >> num && LineCount != 0)   
> 输入一串数而不是一个数 回车之后开始判断，cin会读第一个数后跳出循环，剩下的数符号都在缓冲区里  
 `要把输入个数放在前边判断否则你需要输入更多的数来终止while`

### c++ size()返回的数据类型        
    
无符号数(2个字节16位65536 or 32位4字节 看具体的操作系统)  
解决办法:  
>int len=A.size()   
int(A.size())  
(int)A.size() C风格    

操作符隐式转换:      
>unsigend int a=0;
>int b=-1;
>cout<<a+b   
>输出把-1转为无符号数 因为计算机是补码存 -1的整数存 1111 1111 1111 1111......，输出非常大的数。
   
> cout<<int(a+b)   
把结果看成 -1 输出。  
无符号数相对于整数不会溢出 只是截取可以填进去的部分。

## 代码杂谈 
1.本文写的的输入必须在最后一行输入完回车后，再加一个回车即可退出while，此时缓冲区只有一个/n ，使用cin.get读走。   
2.如果while判断里面的调换位置既不会退出 因为你回车之后 ->cin不会读（因为是空格）->while判断语句不执行  
3.代码最前一段是通过解决解绑C++输入流兼容C导致的效率低下问题    
  
`本文测出系统的bug 空数组是size为行1 列0 用empty是无法判断`    
`本文是使用for循环增加了一些判断语句导致时间开销，使用while会提示速度(但是可能就无法发现上面那个问题)`

