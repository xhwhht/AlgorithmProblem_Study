## 思路:  
__排序 O(n)+数组下标连续__

## 题目：
在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的。请找出数组中任意一个重复的数字。  
例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1。

数据范围：0≤n≤10000 

## 知识点
1.利用数组下标连续和题目提到数与下标范围一致，可以通过排序将数与下标对应。  
&ensp; 时间复杂度 __O(n)__ 空间复杂度 __O(1)__ 对原数组进行破坏没有开辟新空间。  

2.计数排序 :创建一个大小为number.size()的数组count把数填到对应的下标位置 。  
&ensp; 时间复杂度 __O(n)__ 空间复杂度 __O(n)__ 
&ensp; 此方法当n很大时空间复杂度较差  
  
普通数组不支持输入一个变量来分配空间(vector支持)， 注意一定要初始化为0！！!  
> 1.int count[10001]={0} 只对数组有效   
> 2.输入n->  vector < int > count(n) -> count(n,0) (不可以用push_back此时将会在n后边添加元素)    nums.reserve(a > 128 ? 128 : a);
> 3.memset(count, 0, sizeof(count)) &ensp; &ensp; 如果count为char不需要sizeof  &ensp; &ensp;__不要对vector 使用__      
> &ensp;用memset给一个数组初始化为0、-1或一个很大的数，但是不要用memset函数来赋具体的值。
> 4. 普通的字符数组 char a[10]={"abdc"} 初始化后五位用'\0'填充。


3.C++ 创建类通过类调用函数如`Test.Fun(&var) `这样传的是地址,地址是常量所以Fun函数输入参数必须是const修饰。  
 &ensp; 传引用是在定义函数时候体现，对引用理解不透彻！！！class必须是在main前声明
