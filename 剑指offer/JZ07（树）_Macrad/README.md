## 思路:     
* 递归
* 栈  
借助栈来解决问题需要关注一个问题，就是前序遍历挨着的两个值比如m和n，它们会有下面两种情况之一的关系。
1.要么先序后一个是前一个的左节点
2.要么先序后一个是前一个的右节点或者其祖先的右节点
同时顺序遍历pre和vin两个序列，判断是否是左节点，如果是不断向左深入，用栈记录祖先，如果不是需要弹出栈回到相应的祖先，然后进入右子树，整个过程类似非递归前序遍历


## 题目：重建二叉树    
给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。    
例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。  
要求：空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)    


## 代码相关  
* 栈的比较难理解，没有贴代码；核心思路栈来记录某个右树的祖先；
* 递归方法 前序子序列（左和右）第一个一定是“根结点”
* 输入格式：  
7
1 2 3 4 5 6 7
7
3 2 4 1 6 5 7
