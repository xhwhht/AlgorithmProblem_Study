## 思路:  
观察数组寻找一个数是一行的最大值 同时是一列最小值 这样判断可以直接一行or一列
右上角 or 左下角

## 题目：
在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。  
[
[1,2,8,9],  
[2,4,9,12],  
[4,7,10,13],  
[6,8,11,15]   
]  
给定 target = 7，返回 true。  
给定 target = 3，返回 false。  

数据范围：矩阵的长宽满足 0 <= n,m≤500 ， 矩阵中的值满足 0 \≤val≤10^9  
 
进阶：空间复杂度 O(1) ，时间复杂度 O(n+m)  

## 知识点  


3.C++   
输入流：遇到回车全部放入缓冲区就开始读，cin可以忽略回车，空格。cin.get() 返回的ascii 默认的char型
如 while（cin>>num）{cin.get(); cin.get;}  
输入：1空格2空格3空格空格回车  
输出：cin读了1 cin.get读了空格  cin.get读了2返回2的ascii码 cin读了3 cin.get 读了俩个空格此时，此时停止读取缓存区还有一个回车
输入：1空格空格空格3回车  
cin读了1 cin.get读了空格  cin.get读了空格  cin读3 cin.get读了回车   cin前的空格会从缓冲区消失
如果有If（cin.get）也会读走  

# cin先读因为在while 然后是cin.get
while (cin >> num && LineCount != 0) LineCount=1,输入一串数 回车之后开始判断，cin会读第一个数，剩下的数符号都在缓冲区里

本文写的的输入必须在最后一行输入完回车后，再加一个回车即可退出while，此时缓冲区只有一个/n   使用cin.get读走 
如果while判断里面的调换位置既不会退出 因为你回车之后 cin不会读while判断语句不执行

无符号数 2个字节 16位 65536 or 32位 4字节 看具体的操作系统
解决办法 int len=A.size() or int（A.size()） or(int)A.size()  

操作符会隐式转换：  
unsigend int a=0;
int b=-1;
cout<<a+b 输出把-1转为无符号数 因为计算机是补码存 -1的整数存 1111 1111 1111 1111......，最后输出 非常大的数
如果 cout<<int(a+b) 就会把数字看成 -1 输出
无符号数相对于整数不会溢出 只是截取可以填进去的部分

补充 看一下 memest 用来初始化
#define 0x 定义二进制数